// Package api provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"io"
	"net/http"
	"strings"
)

// ConsentCheckRequest defines component schema for ConsentCheckRequest.
type ConsentCheckRequest struct {
	Actor        Identifier `json:"actor"`
	Custodian    Identifier `json:"custodian"`
	ResourceType string     `json:"resourceType"`
	Subject      Identifier `json:"subject"`
}

// ConsentCheckResponse defines component schema for ConsentCheckResponse.
type ConsentCheckResponse struct {
	ConsentGiven *string `json:"consentGiven,omitempty"`
	Limitations  *string `json:"limitations,omitempty"`
}

// ConsentQueryRequest defines component schema for ConsentQueryRequest.
type ConsentQueryRequest struct {
	Actor Identifier      `json:"actor"`
	Page  *PageDefinition `json:"page,omitempty"`
	Query interface{}     `json:"query"`
}

// ConsentQueryResponse defines component schema for ConsentQueryResponse.
type ConsentQueryResponse struct {
	Page         PageDefinition      `json:"page"`
	Results      []SimplifiedConsent `json:"results"`
	TotalResults int32               `json:"totalResults"`
}

// Identifier defines component schema for Identifier.
type Identifier string

// PageDefinition defines component schema for PageDefinition.
type PageDefinition struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// SimplifiedConsent defines component schema for SimplifiedConsent.
type SimplifiedConsent struct {
	Actors    []Identifier `json:"actors"`
	Custodian Identifier   `json:"custodian"`
	Resources []string     `json:"resources"`
	Subject   Identifier   `json:"subject"`
}

// SubjectQuery defines component schema for SubjectQuery.
type SubjectQuery string

// Client which conforms to the OpenAPI3 specification for this service. The
// server should be fully qualified with shema and server, ie,
// https://deepmap.com.
type Client struct {
	Server string
	Client http.Client
}

// CreateConsent request with JSON body
func (c *Client) CreateConsent(ctx context.Context, body SimplifiedConsent) (*http.Response, error) {
	req, err := NewCreateConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// CheckConsent request with JSON body
func (c *Client) CheckConsent(ctx context.Context, body ConsentCheckRequest) (*http.Response, error) {
	req, err := NewCheckConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// QueryConsent request with JSON body
func (c *Client) QueryConsent(ctx context.Context, body ConsentQueryRequest) (*http.Response, error) {
	req, err := NewQueryConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// NewCreateConsentRequest generates requests for CreateConsent with JSON body
func NewCreateConsentRequest(server string, body SimplifiedConsent) (*http.Request, error) {
	var bodyReader io.Reader

	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	return NewCreateConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConsentRequestWithBody generates requests for CreateConsent with non-JSON body
func NewCreateConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryURL := fmt.Sprintf("%s/consent", server)

	req, err := http.NewRequest("POST", queryURL, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCheckConsentRequest generates requests for CheckConsent with JSON body
func NewCheckConsentRequest(server string, body ConsentCheckRequest) (*http.Request, error) {
	var bodyReader io.Reader

	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	return NewCheckConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckConsentRequestWithBody generates requests for CheckConsent with non-JSON body
func NewCheckConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryURL := fmt.Sprintf("%s/consent/check", server)

	req, err := http.NewRequest("POST", queryURL, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewQueryConsentRequest generates requests for QueryConsent with JSON body
func NewQueryConsentRequest(server string, body ConsentQueryRequest) (*http.Request, error) {
	var bodyReader io.Reader

	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	return NewQueryConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryConsentRequestWithBody generates requests for QueryConsent with non-JSON body
func NewQueryConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryURL := fmt.Sprintf("%s/consent/query", server)

	req, err := http.NewRequest("POST", queryURL, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create a new consent record (POST /consent)
	CreateConsent(ctx echo.Context) error
	// Send a request for checking if the given combination exists (POST /consent/check)
	CheckConsent(ctx echo.Context) error
	// Do a query for available consent (POST /consent/query)
	QueryConsent(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// CreateConsent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateConsent(ctx)
	return err
}

// CheckConsent converts echo context to params.
func (w *ServerInterfaceWrapper) CheckConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckConsent(ctx)
	return err
}

// QueryConsent converts echo context to params.
func (w *ServerInterfaceWrapper) QueryConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.QueryConsent(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/consent", wrapper.CreateConsent)
	router.POST("/consent/check", wrapper.CheckConsent)
	router.POST("/consent/query", wrapper.QueryConsent)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8RXbW/bNhD+KwduwLZCcOym6IuAfGjTLc3WJVmSfmqL4kyebLYUqZKUW6Pwfx+Okvwm",
	"rW9p13wIbPN0fO7uuedOH4R0ZeUs2RhE/kEEOacS08djZwPZeDwn+eaS3tYUIv9ceVeRj5qSEcroPH/4",
	"2VMhcvHTwcbfQevs4FSRjbrQ5MUqE7IO0SmN9sse8xRc7SVdLyviJxUF6XUVtbMiF388Ob2EzgTiHCPo",
	"AL6BTUpkgt5jWRkSuTifBvILTE9mIiZ/IkSv7YwvCvX0Ncn4JegSvLe19qRE/nztYTvWrE3VXiAvV9le",
	"okPFX/uZlo3ViV5QyhzZuuTLlhREJqwTmTC61Bzsy4Go0lmKOfSzVzgPRR1rT1AH2k2WNUsoCUPtqeQE",
	"AHoCNMa9I5XB1fnvF2Bd7CdyLyeujtKVOwH/U5NfbjFrF1M6BYkWSMc5eZgSIBS1MRDpfYRA6OUcmuvA",
	"6DcEt8B5QGjTD3pToezmtK1wRp964gJn9JgKbXUKYpWJtxwFP+YsnRcif/5xB1cN9BS7WGWfj+/lfr47",
	"tjUA+ln/L5p9XZieQm0aBdGRyvApD1e6rAxDVy0qdtISCL3HZfruIprLjeddflzzKdi6nJIHV0AHYe1H",
	"20izge5MEW4g793DmdpKbO/aE7LktdwiF7eMAm4hT5UnjoYZ+ejqLAOcTaVTlAFFOYLT+EsANO9wGYDb",
	"OfpaRlKAAdDCs8szKFzTWDBdAoJy9dQQSGechV/z3wCtgjgny/86BEu+bIGmJs4CH8xYItjdC7vTyreg",
	"9jZ3WuW3R5O7o/t3xqPJaDI5vH//cHR7dGd0d3SYP2j/xi/sp80n+bj5u9dZ2zqGnKyqnLYxbyWrO9QU",
	"i9wXMp/cu/cgPz86I4VVBufPjp4QmjiX6CmD46OzpxlcXR+dkFHkDVqVwdOjE+/IGpfB8dkR3/JKOq/w",
	"laIFGVexMr0yTqIZUvQ9vvY4n7SRP+wzJxOuKAINnu3rW2PYCm2iUZ/kPTZtTKBNFnjiyIYV6/MbbFe7",
	"9jvrhiN4oBsfsmsmYDHXHjaG2QZuryz7qG4+eNsk7c7dbTDdFak821rbXyg80c6gSTNSW8Xt1roJO+31",
	"t4c/0Qa6NTALV5nQtnADebs4hVCR1IWWaTqnezou8J6iJQXABWqDLAYYgem/MYnO0wiu5wRnvd9hztIC",
	"CiNOMSSBUCT9smLVaePP4LhLVgYPOYEZXHaLlHTlVNtmbeBLdGhGf0gwF2SV82v8YNxMS4gO0tBJaiV5",
	"qUnGa6sW4Sipk9GS2jlkseScnVw8XRwmeuiY8joQFvsSmViQD00aWZrGqV8rslhpkYvD0Xg05jbCOE/8",
	"O5CbLqxcs3Jwh6XoTpXIhfSEkbpmbahFIT5yatluYLF9HqvKtAU7eB0aTWn4+RWTb5fF0dfU9Fqa0An6",
	"7fGkT53jhFZBZ8nh3xmP95AyhQ8qg7pZGtdsLXUIm8nBBeo2hk0cAyzehXBqF2i06vbs1I+hLkvkjmoB",
	"AoKld315izgL3LNdVdIG09XoIPHmI5Xi4+9bqKHXn88q1fg7Qeiq3C/D+V9rEmQwdWoJc2dUgHbnbraj",
	"NoKbcWTzZvPNWHJFVgF2h438ccB8sd5eaLa0COi9Ds3u9lEWrbfvYRal4/+FRTuvOj+GRbt7/w9l0TdX",
	"mscOsB06yf96Wsp1cQeIslr9GwAA//9mffFu/hAAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

