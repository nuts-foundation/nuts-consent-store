// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// ConsentCheckRequest defines model for ConsentCheckRequest.
type ConsentCheckRequest struct {

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Actor Identifier `json:"actor"`

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Custodian Identifier `json:"custodian"`

	// Consent class that is requested
	DataClass string `json:"dataClass"`

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Subject Identifier `json:"subject"`

	// Date at which consent has to be valid. Optional, when empty, Now() is used. format: 2020-01-01T12:00:00+01:00
	ValidAt *string `json:"validAt,omitempty"`
}

// ConsentCheckResponse defines model for ConsentCheckResponse.
type ConsentCheckResponse struct {
	ConsentGiven *string `json:"consentGiven,omitempty"`

	// for future use
	Limitations *string `json:"limitations,omitempty"`
}

// ConsentQueryRequest defines model for ConsentQueryRequest.
type ConsentQueryRequest struct {

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Actor *Identifier `json:"actor,omitempty"`

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Custodian *Identifier     `json:"custodian,omitempty"`
	Page      *PageDefinition `json:"page,omitempty"`

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Subject *Identifier `json:"subject,omitempty"`

	// Date at which consent has to be valid. Optional, when empty, Now() is used. format: 2020-01-01T12:00:00+01:00
	ValidAt *string `json:"validAt,omitempty"`
}

// ConsentQueryResponse defines model for ConsentQueryResponse.
type ConsentQueryResponse struct {
	Page    PageDefinition   `json:"page"`
	Results []PatientConsent `json:"results"`

	// Total number of results
	TotalResults int `json:"totalResults"`
}

// ConsentRecord defines model for ConsentRecord.
type ConsentRecord struct {

	// Array of consent classes
	DataClasses []string `json:"dataClasses"`

	// the hash of the previous version of the hash
	PreviousRecordHash *string `json:"previousRecordHash,omitempty"`

	// the unique hash for the consent record proving consent has been given, can be seen as the unique ID for a consentRecord
	RecordHash string `json:"recordHash"`

	// DateTime from which a record is valid (inclusive)
	ValidFrom ValidFrom `json:"validFrom"`

	// DateTime to which a record is valid (exclusive)
	ValidTo *ValidTo `json:"validTo,omitempty"`

	// the version number for the record, starts at 1, equals the length of the chain when following the previousRecordHash
	Version *int `json:"version,omitempty"`
}

// Identifier defines model for Identifier.
type Identifier string

// PageDefinition defines model for PageDefinition.
type PageDefinition struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// PatientConsent defines model for PatientConsent.
type PatientConsent struct {

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Actor Identifier `json:"actor"`

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Custodian Identifier `json:"custodian"`

	// Id as generated by the HMAC of custodian(subject-actor)
	Id      string          `json:"id"`
	Records []ConsentRecord `json:"records"`

	// Generic identifier used for representing BSN, agbcode, etc. It's always constructed as an URN followed by a double colon (:) and then the identifying value of the given URN
	Subject Identifier `json:"subject"`
}

// ValidFrom defines model for ValidFrom.
type ValidFrom string

// ValidTo defines model for ValidTo.
type ValidTo string

// CreateConsentJSONBody defines parameters for CreateConsent.
type CreateConsentJSONBody PatientConsent

// CheckConsentJSONBody defines parameters for CheckConsent.
type CheckConsentJSONBody ConsentCheckRequest

// QueryConsentJSONBody defines parameters for QueryConsent.
type QueryConsentJSONBody ConsentQueryRequest

// FindConsentRecordParams defines parameters for FindConsentRecord.
type FindConsentRecordParams struct {

	// flag to indicate to only return a value when the given record is the latest in the chain
	Latest *bool `json:"latest,omitempty"`
}

// CreateConsentRequestBody defines body for CreateConsent for application/json ContentType.
type CreateConsentJSONRequestBody CreateConsentJSONBody

// CheckConsentRequestBody defines body for CheckConsent for application/json ContentType.
type CheckConsentJSONRequestBody CheckConsentJSONBody

// QueryConsentRequestBody defines body for QueryConsent for application/json ContentType.
type QueryConsentJSONRequestBody QueryConsentJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateConsent request  with any body
	CreateConsentWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateConsent(ctx context.Context, body CreateConsentJSONRequestBody) (*http.Response, error)

	// CheckConsent request  with any body
	CheckConsentWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CheckConsent(ctx context.Context, body CheckConsentJSONRequestBody) (*http.Response, error)

	// QueryConsent request  with any body
	QueryConsentWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	QueryConsent(ctx context.Context, body QueryConsentJSONRequestBody) (*http.Response, error)

	// DeleteConsent request
	DeleteConsent(ctx context.Context, consentRecordHash string) (*http.Response, error)

	// FindConsentRecord request
	FindConsentRecord(ctx context.Context, consentRecordHash string, params *FindConsentRecordParams) (*http.Response, error)
}

func (c *Client) CreateConsentWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsent(ctx context.Context, body CreateConsentJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CheckConsentWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCheckConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CheckConsent(ctx context.Context, body CheckConsentJSONRequestBody) (*http.Response, error) {
	req, err := NewCheckConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) QueryConsentWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewQueryConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) QueryConsent(ctx context.Context, body QueryConsentJSONRequestBody) (*http.Response, error) {
	req, err := NewQueryConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConsent(ctx context.Context, consentRecordHash string) (*http.Response, error) {
	req, err := NewDeleteConsentRequest(c.Server, consentRecordHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) FindConsentRecord(ctx context.Context, consentRecordHash string, params *FindConsentRecordParams) (*http.Response, error) {
	req, err := NewFindConsentRecordRequest(c.Server, consentRecordHash, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewCreateConsentRequest calls the generic CreateConsent builder with application/json body
func NewCreateConsentRequest(server string, body CreateConsentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConsentRequestWithBody generates requests for CreateConsent with any type of body
func NewCreateConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consent")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCheckConsentRequest calls the generic CheckConsent builder with application/json body
func NewCheckConsentRequest(server string, body CheckConsentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckConsentRequestWithBody generates requests for CheckConsent with any type of body
func NewCheckConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consent/check")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewQueryConsentRequest calls the generic QueryConsent builder with application/json body
func NewQueryConsentRequest(server string, body QueryConsentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryConsentRequestWithBody generates requests for QueryConsent with any type of body
func NewQueryConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consent/query")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteConsentRequest generates requests for DeleteConsent
func NewDeleteConsentRequest(server string, consentRecordHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "consentRecordHash", consentRecordHash)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consent/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindConsentRecordRequest generates requests for FindConsentRecord
func NewFindConsentRecordRequest(server string, consentRecordHash string, params *FindConsentRecordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "consentRecordHash", consentRecordHash)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consent/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Latest != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "latest", *params.Latest); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateConsent request  with any body
	CreateConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateConsentResponse, error)

	CreateConsentWithResponse(ctx context.Context, body CreateConsentJSONRequestBody) (*CreateConsentResponse, error)

	// CheckConsent request  with any body
	CheckConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CheckConsentResponse, error)

	CheckConsentWithResponse(ctx context.Context, body CheckConsentJSONRequestBody) (*CheckConsentResponse, error)

	// QueryConsent request  with any body
	QueryConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*QueryConsentResponse, error)

	QueryConsentWithResponse(ctx context.Context, body QueryConsentJSONRequestBody) (*QueryConsentResponse, error)

	// DeleteConsent request
	DeleteConsentWithResponse(ctx context.Context, consentRecordHash string) (*DeleteConsentResponse, error)

	// FindConsentRecord request
	FindConsentRecordWithResponse(ctx context.Context, consentRecordHash string, params *FindConsentRecordParams) (*FindConsentRecordResponse, error)
}

type CreateConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsentCheckResponse
}

// Status returns HTTPResponse.Status
func (r CheckConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsentQueryResponse
}

// Status returns HTTPResponse.Status
func (r QueryConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindConsentRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsentRecord
}

// Status returns HTTPResponse.Status
func (r FindConsentRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindConsentRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateConsentWithBodyWithResponse request with arbitrary body returning *CreateConsentResponse
func (c *ClientWithResponses) CreateConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateConsentResponse, error) {
	rsp, err := c.CreateConsentWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsentResponse(rsp)
}

func (c *ClientWithResponses) CreateConsentWithResponse(ctx context.Context, body CreateConsentJSONRequestBody) (*CreateConsentResponse, error) {
	rsp, err := c.CreateConsent(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsentResponse(rsp)
}

// CheckConsentWithBodyWithResponse request with arbitrary body returning *CheckConsentResponse
func (c *ClientWithResponses) CheckConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CheckConsentResponse, error) {
	rsp, err := c.CheckConsentWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCheckConsentResponse(rsp)
}

func (c *ClientWithResponses) CheckConsentWithResponse(ctx context.Context, body CheckConsentJSONRequestBody) (*CheckConsentResponse, error) {
	rsp, err := c.CheckConsent(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCheckConsentResponse(rsp)
}

// QueryConsentWithBodyWithResponse request with arbitrary body returning *QueryConsentResponse
func (c *ClientWithResponses) QueryConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*QueryConsentResponse, error) {
	rsp, err := c.QueryConsentWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseQueryConsentResponse(rsp)
}

func (c *ClientWithResponses) QueryConsentWithResponse(ctx context.Context, body QueryConsentJSONRequestBody) (*QueryConsentResponse, error) {
	rsp, err := c.QueryConsent(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseQueryConsentResponse(rsp)
}

// DeleteConsentWithResponse request returning *DeleteConsentResponse
func (c *ClientWithResponses) DeleteConsentWithResponse(ctx context.Context, consentRecordHash string) (*DeleteConsentResponse, error) {
	rsp, err := c.DeleteConsent(ctx, consentRecordHash)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConsentResponse(rsp)
}

// FindConsentRecordWithResponse request returning *FindConsentRecordResponse
func (c *ClientWithResponses) FindConsentRecordWithResponse(ctx context.Context, consentRecordHash string, params *FindConsentRecordParams) (*FindConsentRecordResponse, error) {
	rsp, err := c.FindConsentRecord(ctx, consentRecordHash, params)
	if err != nil {
		return nil, err
	}
	return ParseFindConsentRecordResponse(rsp)
}

// ParseCreateConsentResponse parses an HTTP response from a CreateConsentWithResponse call
func ParseCreateConsentResponse(rsp *http.Response) (*CreateConsentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseCheckConsentResponse parses an HTTP response from a CheckConsentWithResponse call
func ParseCheckConsentResponse(rsp *http.Response) (*CheckConsentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CheckConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsentCheckResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseQueryConsentResponse parses an HTTP response from a QueryConsentWithResponse call
func ParseQueryConsentResponse(rsp *http.Response) (*QueryConsentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &QueryConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsentQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteConsentResponse parses an HTTP response from a DeleteConsentWithResponse call
func ParseDeleteConsentResponse(rsp *http.Response) (*DeleteConsentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseFindConsentRecordResponse parses an HTTP response from a FindConsentRecordWithResponse call
func ParseFindConsentRecordResponse(rsp *http.Response) (*FindConsentRecordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FindConsentRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsentRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create a new consent record for a C-S-A combination.
	// (POST /consent)
	CreateConsent(ctx echo.Context) error
	// Send a request for checking if the given combination exists
	// (POST /consent/check)
	CheckConsent(ctx echo.Context) error
	// Do a query for available consent
	// (POST /consent/query)
	QueryConsent(ctx echo.Context) error
	// Remove a consent record for a C-S-A combination.
	// (DELETE /consent/{consentRecordHash})
	DeleteConsent(ctx echo.Context, consentRecordHash string) error
	// Retrieve a consent record by hash, use latest query param to only return a value if the given consent record is the latest in the chain.
	// (GET /consent/{consentRecordHash})
	FindConsentRecord(ctx echo.Context, consentRecordHash string, params FindConsentRecordParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// CreateConsent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateConsent(ctx)
	return err
}

// CheckConsent converts echo context to params.
func (w *ServerInterfaceWrapper) CheckConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckConsent(ctx)
	return err
}

// QueryConsent converts echo context to params.
func (w *ServerInterfaceWrapper) QueryConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.QueryConsent(ctx)
	return err
}

// DeleteConsent converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteConsent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "consentRecordHash" -------------
	var consentRecordHash string

	err = runtime.BindStyledParameter("simple", false, "consentRecordHash", ctx.Param("consentRecordHash"), &consentRecordHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consentRecordHash: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteConsent(ctx, consentRecordHash)
	return err
}

// FindConsentRecord converts echo context to params.
func (w *ServerInterfaceWrapper) FindConsentRecord(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "consentRecordHash" -------------
	var consentRecordHash string

	err = runtime.BindStyledParameter("simple", false, "consentRecordHash", ctx.Param("consentRecordHash"), &consentRecordHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consentRecordHash: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params FindConsentRecordParams
	// ------------- Optional query parameter "latest" -------------

	err = runtime.BindQueryParameter("form", true, false, "latest", ctx.QueryParams(), &params.Latest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter latest: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindConsentRecord(ctx, consentRecordHash, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/consent", wrapper.CreateConsent)
	router.POST("/consent/check", wrapper.CheckConsent)
	router.POST("/consent/query", wrapper.QueryConsent)
	router.DELETE("/consent/:consentRecordHash", wrapper.DeleteConsent)
	router.GET("/consent/:consentRecordHash", wrapper.FindConsentRecord)

}

